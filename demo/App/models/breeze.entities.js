(function () {
  'use strict';

  // define factory
  var serviceId = 'breeze.entities';
  angular.module('app').factory(serviceId,
    ['common', breezeEntities]);

  // create factory
  function breezeEntities(common) {
    var metadataStore = new breeze.MetadataStore();

    // init factory
    init();

    return {
      metadataStore: metadataStore
    };

    // init factory
    function init() {
      common.logger.log('init metadataStore', metadataStore, serviceId);

      // create entities to map from sharepoint > breeze
      fillMetadataStore();
    }

    // define metadata for entities for breeze that we pull form sharepoint
    function fillMetadataStore() {
      // namespace of the corresponding classes on the server
      var namespace = '';

      // Breeze Labs: breeze.metadata.helper.js
      // https://github.com/IdeaBlade/Breeze/blob/master/Breeze.Client/Scripts/Labs/breeze.metadata-helper.js
      // The helper reduces data entry by applying common conventions
      // and converting common abbreviations (e.g., 'type' -> 'dataType')
      var helper = new breeze.config.MetadataHelper(namespace, breeze.AutoGeneratedKeyType.Identity);

      // addType - make it easy to add the type to the store using the helper
      var addType = function (typeDef) {
        var entityType = helper.addTypeToStore(metadataStore, typeDef);
        addDefaultSelect(entityType);
        return entityType;
      };

      // create the entity metadata and add to the store
      addLearningPathType();
      addLearningItemType();

      // add 'defaultSelect' custom metadata that selects for all mapped data properties
      // could be used by SharePoint dataservice adapter to exclude unwanted property data
      // in query payload
      function addDefaultSelect(type) {
        var custom = type.custom;
        // bail out if defined by hand already
        if (custom && custom.defaultSelect != null) { return; }

        var select = [];
        type.dataProperties.forEach(function (prop) {
          if (!prop.isUnmapped) { select.push(prop.name); }
        });
        if (select.length) {
          if (!custom) { type.custom = custom = {}; }
          custom.defaultSelect = select.join(',');
        }
        return type;
      }

      // add the learning path type to the metadata store
      function addLearningPathType() {
        addType({
          name: 'LearningPath',
          defaultResourceName: 'getbytitle(\'Learning Paths\')/items',
          dataProperties: {
            Id:               { type: breeze.DataType.Int32 },
            Title:            { nullable: false },
            OData__Comments:  {},
            Created:          { type: breeze.DataType.DateTime },
            Modified:         { type: breeze.DataType.DateTime }
          },
          navigationProperties: {
            LearningItems: {
              type: 'LearningItem',
              hasMany: true
            }
          }
        });
      }

      // add the learning item type to the metadata store
      function addLearningItemType() {
        addType({
          name: 'LearningItem',
          defaultResourceName: 'getbytitle(\'Learning Items\')/items',
          dataProperties: {
            Id:               { type: breeze.DataType.Int32 },
            Title:            { nullable: false },
            ItemType:         { nullable: false },
            OData__Comments:  {},
            Url: {
              nullable: false,
              validators: [breeze.Validator.url()]
            },
            LearningPathId: {
              type: breeze.DataType.Int32,
              nullable: false
            },
            Created:          { type: breeze.DataType.DateTime },
            Modified:         { type: breeze.DataType.DateTime }
          },
          navigationProperties: {
            LearningPath: 'LearningPath'
          }
        });
      }
    }

  }

})();